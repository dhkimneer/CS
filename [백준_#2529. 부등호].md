### [# 2529. 부등호]

<br>

- 1초, 256MB
- A: 순서열, 부등호 기호 '<', '>'가 k개 나열된 순서열
- 부등호 기호 앞뒤에 넣을 수 있는 숫자는 0~9까지의 정수, 숫자는 모두 달라야 함
  - 기준은 위치가 될 것이다. (부등호 앞뒤 자리 각각의 위치에 어떤 숫자를 넣어야 하나?)
  - 숫자가 모두 달라야 함은 곧 숫자를 사용했는지 안했는지 구별해야 한다.
- 부등호 기호 제거한 뒤 숫자를 모두 붙여 하나의 수를 만들 수 있는데 이 수가 바로 부등호 관계를 만족시키는 정수이다. 하나 이상 존재하기에, (k + 1)자리 정수 중 최댓/최솟값을 찾아야 한다.

<br>

- 입력값
  - 첫 줄에 부등호 문자 개수를 나타내는 정수 k
  - 다음줄에 k개 부등호 기호가 하나의 공백을 두고 한 줄에 모두 제시
    - 2 <= k <= 9

<br>

- 출력값
  - 부등호 관계 만족하는 (k + 1)자리의 최대 / 최소 정수를 첫째 줄과 둘째 줄에 각각 출력
  - 출력 정수는 하나의 '문자열'이 되도록 해야 한다.
  - 첫 자리가 0인 경우도 정수에 포함되어야 함

<br>

<br>

#### [풀이1. BruteForce]

<br>

1. 시간 복잡도 계산

   <br>

   - 기준은 위에 서술했듯 부등호 앞뒤 자리의 '위치'가 될 것이다.
   - 부등호가 입력값으로 k개 존재하므로, (k + 1)자리의 위치에 과연 어떤 숫자가 들어갈 것인가를 판별한다.
   - 최악의 경우 k = 9이므로, 10자리의 각 위치에 어떤 숫자가 들어갈지 판단하자.
   - 각 위치에 0~9까지의 정수가 오기가 가능하므로 (문제에 첫 자리가 0인 경우도 포함한다고 했음)
     - O(10!)이 되는데, 10! = 3628800이므로 브루트포스 풀이가 가능하다.

<br>

2. 함수 안에 들어갈 인자 확인

   <br>

   - 첫 번째 자리에 어떤 숫자를 넣으면, 다음 자리 턴으로 넘어간다.
     - index가 필요하다.
     - 그런데 이 때, 각 숫자들 사이에 부등호가 껴 있기 때문에 주의해야 한다.

   <br>

   - 숫자는 모두 달라야한다고 했으므로, 사용했던 숫자들을 모을 리스트가 필요하다.
     - used_number가 필요하다.
     - [why?]
       - 물론 숫자를 썼는지 안 썼는지 check가 필요하다.
       - 하지만, 이는 함수의 인자로 들어갈 필요가 없다.

   <br>

   ==========================================================

   <br>

   - 어떤 숫자를 사용했는지 -> index
     - 이건 위의 다음 자리 턴으로 넘어가는 것으로 이해하는 게 맞을 듯하다.

   <br>

   - 거기까지 만든 수 -> num
     - 문자열, 수를 이어붙여야 하기 때문
     - 다음 경우를 호출할 때마다 값이 연속적으로 바뀌어 있다.

<br>

3. 3가지 경우를 확인한다.

   <br>

   1) 다음 경우 호출 시

   <br>

   - go(index + 1, num + str(i))
     - 부등호 낀 상태로 전체를 판단하는 것은 쉽지 않으니, 우선 숫자를 구해놓고 나중에 따로 부등호 관련 문제를 따지자.

   <br>

   2) 정답을 찾은 경우

   <br>

   - index == (n + 1)

     - 0 ~ n까지라고 indexing 가정

     <br>

   - 이후 부등호 관계 만족하는지 확인하고(별도의 함수 지정), 맞다면 리스트에 추가한다.

     - 리스트를 사용해야 추후에 sort 함수를 쓰고 최솟값, 최댓값을 도출하기에 편하다.

   <br>

   3) 불가능한 경우

   <br>

   - index 관련 문제는 없다.

     <br>

   - 부등호 관계를 따지는 데 있어 A의 부등호 순서열에 부합하지 않을 경우 답에서 탈락한다.

     <br>

     ```python
     def ok(num: str) -> bool:
         for i in range(n):
             if a[i] == '<':
                 if num[i] > num[i + 1]:
                     return False
                 
             if a[i] == '>':
                 if num[i] < num[i + 1]:
                     return False
                 
             return True
     ```

<br>

4. 소스 구현

<br>

```python
# 종료 조건을 담은 함수 선제시 (3번)
def ok(num: str) -> bool:
    for i in range(n):
        if a[i] == '<':
            if num[i] > num[i + 1]:
                return False
            
        if a[i] == '>':
            if num[i] < num[i + 1]:
                return False
            
        return True
            
# 함수 (1, 2번)
def go(index: int, num: str) -> list[str]:
    # 정답을 찾은 경우 (2번)
    if index == (n + 1):
        if ok(num):
            ans.append(num)
        return
    
    # 재귀 호출 (1번)
    for i in range(10):
        if check[i]:
            continue
        check[i] = True
        go(index + 1, num + str(i))
        # 첫번째 index를 i로 정한 뒤 벌어지는 모든 일들이 해결 by 재귀 호출
        # 이제 index에는 다른 i가 오게 되기에 i가 사용되지 않았다라고 정정해줘야 함
        # 즉, 처음부터 시작해(i = 0) 위의 재귀호출이 끝나게 되면
        # 다음 순서는 i = 1일텐데, 이는 다른 i가 온 것이므로(다른 경우를 따지는 것)
        # check[i] = True를 False로 바꿔줘야 한다. 
        check[i] = False
        
n = int(input())
a = input().split()
ans = []
check = [False] * 10
go(0, '')

# 리스트 구했으니 최대/최소를 구하러 감
ans.sort()
print(ans[-1])
print(ans[0])
```

<br>

<br>

<br>

#### [풀이2. Backtracking]

<br>

- 최적화할 수 없을까?

  <br>

  - 풀이 1에서는 일단 index 0 ~ n까지 숫자를 다 넣은 다음, 부등호 관계를 분석했다.
  - 숫자를 넣는 과정에서 입력값에서 정의한 부등호 관계에 어긋날 경우 바로 그 함수 호출을 중단하는 것이 훨씬 시간을 줄일 수 있을 것이다.

<br>

- 어떻게 해야할까?

  <br>

  - '숫자를 넣는 과정'에서 최적화시킬 수 있다.
  - 또한 재귀가 호출되기 전에 정의되어야 한다.

  <br>

  - 반대로 숫자를 넣는 과정에서 부등호 관계에 어긋나지 '않는다면'을 표현하자.

    <br>

    1. index == 0이면 시작점을 정의하는 것이므로 함수를 호출해도 된다.

    2. 위에서 적었던 ok함수를 전면적으로 바꿔야 한다.

       <br>

       - why?

         <br>

         - ok함수는 숫자를 다 구하고 나서야 쓸 수 있는 함수이기 때문이다.
         - 하지만, 숫자를 넣는 '과정'에서 실시간으로 부등호 관계를 분석하고 싶다!

       - how?

         <br>

         ```python
         def satisfied(x: str, y: str, sign: str) -> bool:
             if sign == '<':
                 if x > y:
                     return False
                 
             if sign == '>':
                 if x < y:
                     return False
                 
             return True
         ```

       <br>

    3. 이제 종합하여 재귀 호출 전에 조건문을 추가한다.

       <br>

       ```python
       ...
       
       if check[i]:
           continue
           
       # 추가
       # 직전 숫자와 이번에 새로 들어오는 숫자를 그 사이에 있는 부등호로 비교한다.
       # 이후 그 결과가 이상이 없다면 함수 호출하고, 아니면 중단한다.
       # 숫자 str끼리 비교 가능하다!
       if index == 0 or satisfied(num[index - 1], str(i), a[index - 1]):
           check[i] = True
           go(index + 1, num + str(i))
           check[i] = False
           
       ...
       ```

<br>

- 전체 소스 구현

<br>

```python
def satisfied(x: str, y: str, sign: str) -> bool:
    if sign == '<':
        if x > y:
            return False
        
    if sign == '>':
        if x < y:
            return False
        
    return True


def go(index: int, num: str) -> list[str]:
    # 종료 조건
    if index == (n + 1):
        ans.append(num)
        return
    
    # 재귀 호출
    for i in range(10):
        if check[i]:
            continue
            
        # backtracking 조건 추가
        if index == 0 or satisfied(num[index - 1], str(i), a[index - 1]):
            check[i] = True
            go(index + 1, num + str(i))
            check[i] = False

            
n = int(input())
a = input().split()
ans = []
check = [False] * 10

go(0, '')
ans.sort()
print(ans[-1])
print(ans[0])
```

