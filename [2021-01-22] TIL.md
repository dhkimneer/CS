## HTTP 완벽 가이드 2장. URL과 리소스
<br>
[ Objectives ]
1. URL 문법, URL 컴포넌트의 의미 및 역할
2. 상대 URL, 단축 URL
3. URL 인코딩과 문자 규칙
4. 공통 URL scheme
5. URL(URN 포함)의 미래
<br>
[ Contents ]
1. URL 컴포넌트 의미 및 역할
URL은 rough하게 말하면 리소스 위치를 가리킴
<br>
<스킴>://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>
<br>
- 주 컴포넌트는 스킴, 호스트(IP주소 갖는 시스템), 경로임
다시 보자면 스킴은 리소스를 가져오는데 어떤 프로토콜을 사용해 서버에 접근하는지를 알려주는 것, 호스트는 리소스를 호스팅하는 IP주소(서버가 어디있냐?), 경로는 리소스가 서버 내 어디에 위치하는지를 알려주는 것.
<br>
- 주의할 점은, HTTP 서버가 일반적으로 객체 일부가 아니라 전체를 다루기에 클라이언트가 서버에 프래그먼트를 전달하지 않음.
즉 사용자 명령 - 클라이언트가 프래그먼트 전까지의 내용을 요청 - 서버의 HTML 페이지 반환 - 이후 브라우저가 서버로부터 리소스를 '전부' 내려받고 그 중 원하는 '리소스(일부분)'를 프래그먼트를 사용해 보여주는 형태
<br>
<br>
2. 상대 URL, 단축 URL
기저 URL을 출발선으로 필요 경로를 합하여 새로운 절대 URL을 생성함
<br>
<br>
3. 안전하지 않은 문자를 안전하게
<br>
안전한 문자만을 사용하기엔 표현의 한계가 있기에 안전하지 않은 문자들을 표현할 수 있는 인코딩 방식이 고안됨 (by 이스케이프 문자로 변형)
<br>
<br>
4. 공통 scheme
http, https, mailto, ftp, rtsp(u), file, news, telnet, etc...
<br>
5. URL의 미래
URL은 주소일뿐, 실제 이름이 아니기 때문에 리소스가 이동할 경우 URL을 더 이상 사용할 수 없음. 기존 URL이 가리키던 객체를 찾을 방법이 사라짐. 그래서 객체의 위치와 무관한 URN이 등장하였으나 아직 상용화에는 무리가 있음.
<br>
<br>
<br>
## HTTP 완벽 가이드 3장. HTTP 메시지
<br>
[ Objectives ]
1. 메시지가 어떻게 흘러가는지
2. HTTP 메시지의 세 구성 부분
3. 요청 메시지 vs 응답 메시지
4. 요청 메시지가 지원하는 메서드들
5. 응답 메시지가 반환하는 상태 코드들
6. 여러 HTTP 헤더들의 역할
<br>
[ Contents ]
1. 메시지가 어떻게 흘러가는가?
- 인바운드로 이동한다 = 메시지가 서버로 이동한다
- 아웃바운드로 이동한다 = 처리 끝난 후 메시지가 사용자에게로 돌아온다
<br>
- 메시지 유형(ex. 요청 등)에 관계없이 모든 메시지는 다운스트림으로 흐름. 업스트림, 다운스트림 모두 발송자와 수신자의 관계에 대한 단어이므로, 위의 인, 아웃바운드와는 관계가 없다. 어떤 방향이든 다운스트림이다.
<br>
2. HTTP 메시지의 세 구성 부분
- 시작줄 (what message?) / 헤더 블록 (속성) / 본문 (데이터(선택적, 없을 수도 있음))
<br>
3. 요청 메시지 vs 응답 메시지
a. 요청 메시지
<메서드> <요청 URL> <버전>
<헤더>
<br>
<엔터티 본문>
<br>
b. 응답 메시지
<버전> <상태 코드> <사유 구절> -- 달라지는 점
<헤더>
<br>
<엔터티 본문>
<br>
- 주의점은 헤더 or 엔터티 본문이 없더라도 HTTP 헤더의 집합은 항상 빈 줄(줄바꿈 문자열, CRLF)로 끝나야 함
<br>
4. 요청 메시지가 지원하는 메서드들
- 주의할 것은 모든 서버가 모든 메서드를 구현하지는 않는다는 것
<br>
- GET; 서버에게 리소스를 달라고 요청할 때 쓰임
- HEAD; GET과 행동 방식이 같지만, 서버가 엔터티 본문을 반환하지 않음. 헤더만을 돌려줌
 cf. HTTP/1.1 준수를 위해서는 HEAD 메서드가 반드시 구현되어 있어야 함
- PUT; 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 문서를 교체하는 것
- POST; 서버에 있는 리소스에 데이터를 '보내기' 위해 사용
 cf. PUT은 서버에 있는 리소스에 데이터를 '입력하기' 위해 사용
- TRACE; 클라이언트에게 자신의 요청이 서버로 도달했을 때 어떻게 보이게 되는지 알려줌
- OPTIONS; 특정 리소스에게 어떤 메서드가 지원되는지 서버에게 물어보기
- DELETE
- 확장 메서드(HTTP/1.1에 정의되지 않은 메서드)
<br>
5. 응답 메시지가 반환하는 상태 코드들
클라이언트에게 그들의 transaction을 이해할 수 있는 쉬운 방법을 제공
- 100~199: 정보성 상태 코드
* __100 continue에 대한 사항은 계속 읽어볼 것. 지금 이해가 조금 되지 않음..__
- 200~299: 성공 상태 코드
- 300~399: redirect 상태 코드 (리소스에 대해 다른 위치를 사용해라 or 다른 대안 응답)
 redirect 응답에 들어갈 적절한 상태 코드를 선택하기 위해 클라이언트의 http를 분석할 필요.
- 400~499: 클라이언트 에러
- 500~599: 서버 에러 상태 코드 (서버 자체의 오류)
<br>
6. 여러 HTTP 헤더들의 역할
a. 일반 헤더 - 클라이언트, 서버 양측 모두가 사용
b. 요청 헤더 
ex) Accept 헤더: '클라이언트의 요청에 대응하는 어떤 미디어 타입도 받아들이겠다' to 서버
c. 응답 헤더
d. 엔터티 헤더
e. 확장 헤더