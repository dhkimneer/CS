## Ch3. Transport Layer (1)

<br>

#### [3.1. Transport Layer Service]

<br>

- application process간 logical communication을 제공한다.
  - network layer는 host간 logical communication을 제공한다.
- transport protocol은 end system 내에서 작동한다.
  - 보내는 측에서는 메시지를 segment 단위로 잘라 네트워크 계층으로 내려보낸다.
  - 받는 측에서는 segment를 메시지로 재조립해서 app 계층으로 올려보낸다.

<br>

<br>

__인터넷 transport protocol__

<br>

- TCP

  - reliable, in-order delivery를 제공한다.
  - congestion control 수행
    - network overwhelming 방지
  - flow control 수행
    - receiver buffer를 overwhelming하는 것 방지

  <br>

- UDP

  - network layer의 service에 더 얹어주는 것이 없음

  <br>

- 단 TCP, UDP 모두 delay guarantee, bandwidth guarantee 같은 서비스는 제공하지 못한다.

<br>

<br>

<br>

#### [3.2. Multiplexing / Demultiplexing]

<br>

- Transport layer의 가장 본질적인 서비스인 process to process delivery를 위해 필요한 일이 곧 multiplexing / demultiplexing

<br>

<br>

__과정__

<br>

- 2개의 client host, 1개의 server host가 있다고 하자.

- 여러 client host들이 서버 host의 server process를 contact할 것이다.

- 서버 process가 client별로 socket을 별도로 열어 놓고 있다고 가정하자.

- 보내는 측인 client host측에서는 어떤 일이 일어나야 할까?

  - client host에 여러 app이 있을 수 있다.
  - 이들이 모두 transport 계층으로 각자의 socket을 통해 메시지 delivery를 요청한다.
  - transport 입장에서 UDP의 경우 transport layer 위에 여러 app들이 있을 수 있다.
  - app들이 동시에 메시지 delivery를 요청하게 되고, 이 때 내려오는 메시지들을 multiplexing한다.
    - 즉, 메시지마다 목적지를 찍어 network layer로 일렬로 내려보낸다.
  - UDP의 경우 application이 메시지를 내려보내면서 목적지를 가리키므로,
  - 메시지는 segment의 payload에, 목적지는 header에 담아 네트워크 계층으로 내려보낸다.

  <br>

- 받는 측인 server host를 보자.

  - 다른 host의 client process들로부터 메시지를 받는다.
  - 메시지들이 network 계층을 통해 transport 계층으로 올라오게 된다.
  - 이 때 transport 계층은 올라온 메시지들을 목적지 application process로 배달해줘야 한다.
    - 즉, demultiplexing해야 한다.
    - 보내는 측에서 찍어주었던 목적지를 이용해서 목적지 app process로 배달한다.

<br>

<br>

__demultiplexing 작동 방식__

<br>

- 'demultiplexing시 목적지 주소를 찍어준다.'
  - transport layer에서 만들어내는 data unit의 이름은 generic하게 segment라고 부른다.
  - segment는 header와 payload로 이루어진다.
    - 사실 모든 프로토콜 계층에서 만들어내는 data unit은 payload/header로 나뉜다.
  - header에 반드시 포함되어야 하는 field는 source port number, destination port number이다.
    - 즉, 보내는 측에서 나의 포트번호와 목적지의 포트번호를 찍어주는 것이다.
    - 실제로 final destination의 주소는 host 주소와 포트번호로 구성되는데
      - segment의 header에는 포트번호만 있고
      - network layer에 가서야 비로소 host 주소를 붙인다.

<br>

<br>

__connectionless demultiplexing (UDP)__

<br>

- demultiplexing이 일어나는 곳은 receiver측이었다. client host 쪽에서도 receive를 하기도 한다. 아무튼 receiver 측에서의 demultiplexing을 보자는 것이다.
- connectionless의 경우, demultiplexing은 destination port number 및 ip주소를 보고 일어난다.

<br>

- client측에서 socket을 만들면 host-local(그 host에서만 unique) port number가 socket에 할당된다.
  - client socket의 경우에 포트번호가 없다? No!
    - 프로그램 상에서 프로그래머가 사용할 일이 없기에 모를 뿐, OS가 implicit하게 할당해줬다.
- 해당 socket을 통해 datagram을 보낼 때는 목적지 ip주소 및 포트번호를 명시해줘야 한다.
- 이제 host가 UDP segment를 받으면, 목적지 포트번호를 확인하여 포트번호에 해당하는 socket으로 UDP segment를 전달한다.
- 그런데 UDP socket의 경우 server process가 socket 하나만 열어놓고 있다.
- 결국 여러 client들로부터 온 메시지들이 하나의 server socket으로 다 들어오게 된다.

<br>

- 그런데 source port number만으로 demultiplexing이 가능하지 않을까?
  - 아니다. 포트번호는 host-local이었다.
  - 빈번하지는 않겠지만 다른 host로부터 온건데 똑같은 source port number를 달고 오는 경우가 있을 것이다. 그래서 대답해줄 목적지의 주소를 extract할 때 ip주소도 같이 추출해야 한다.

<br>

<br>

__connection-oriented demultiplexing (TCP)__

<br>

- server host에 여러 application들이 있다고 하자. 각 app들은 door socket을 열고 있다.
- 어떤 client가 contact할 경우, 그 client만을 위한 socket을 별도로 연다.
- 그러므로 이 경우에는 receiver측에서 demultiplexing을 위해 4가지를 필요로 한다.
  1. source IP
  2. source port number
     - destination port number는 door socket의 port number이다.
     - 결국 app까지만 알 수 있다.
     - 그런데 connection-oriented의 경우 app을 위해 열려 있는 socket 중 client만을 위한 socket이 무엇인지 알아야 한다.
     - 이를 source IP 및 port number를 가지고 파악한다.
  3. destination IP
     - 내 host로 제대로 왔구나!
  4. destination port number
     - 어느 포트로 가야되는구나!
- connectionless의 경우 demultiplexing을 위해 맞는 host에 왔고, 어느 포트로 가야되는지만 파악하면 되므로 2개만 필요했다. (3, 4번) 이는 각 application process가 socket을 하나 열고 있기 때문이다.

<br>

<br>

<br>

#### [3.3. connectionless transport (UDP)]

<br>

- UDP = User Datagram Protocol

<br>

- connectionless transport, 즉 UDP segment를 주고 받기 전 UDP client와 server간 handshaking 절차가 없다.
- 각 segment를 independent하게 다룬다. 즉, 각 segment는 각자 자신의 목적지 주소를 달고 나간다. 받는 측에서는 동일한 client로부터 온 segment라는 인식 자체를 하지 않는다.

<br>

- 한편, best effort service를 제공한다.
  - network가 segment를 배달해주면 그 segment를 application에 배달한다. 만약 네트워크가 segment를 drop시키고 배달을 못 해주는 경우, UDP는 이를 파악할 수도 없고 application에 알려주지도 않는다. 그저 최선을 다해 서비스를 제공할 뿐이다.
  - 순서가 어긋나도 그대로 application에 전달한다.

<br>

- UDP 사용 application 예

  1. streaming multimedia

     - 지속적인 play가 가능해야 하므로 단위시간당 minimum throughput guarantee가 필요하다. reliable data transfer에는 둔감하다.

     - TCP의 경우 congestion control, flow control 같은 rate control을 transport layer에서 수행한다. app에서 메시지를 생성해서 내려보내도 그 속도로 뽑아주지 않고, TCP 마음대로 network layer로 보내는 속도를 조절한다. 그래서 multimedia는 불편해한다.

     <br>

  2. DNS

     - DNS에서 한 client는 한 번 쿼리 보내고 받으면 끝이다.
     - TCP에서는 이 한 번의 transaction을 위해 client-server간 connection을 맺어야 하는데, overhead가 크다.

     <br>

  3. SNMP Protocol (네트워크 관리 프로토콜)

     - periodic 정보교환이 이뤄질 때도 (정기적) UDP를 선호한다.

     <br>

  4. Reliability가 중요한 application

     - 역설적으로 UDP를 선호한다.
     - 이런 app의 경우 자체적으로 reliability, error에 대해 자가 체크 및 recover 방법을 보유하고 있기에 굳이 transport에서 overhead를 발생시키는 것을 좋아하지 않는다.

<br>

<br>

__UDP__

<br>

- connection establishment가 없기에 user 메시지를 내보낼 때 TCP보다 overhead가 적다.
- 매 메시지가 independent하기에 UDP 내 connection에 대한 상태정보를 sender/receiver 모두 유지할 이유가 없다.

- header의 size가 작다.

  - traffic overhead가 작다.
  - header는 user data를 실어나르기 위해 필요로 하는 byte인데, 사이즈가 크면 클수록 동일한 양의 data를 나르는 데 더 큰 segment를 네트워크로 내보내야 한다.

  <br>

- UDP는 multiplexing/demultiplexing이 하는 일의 전부이다. 그래서 그만을 위한 정보인 (source port number, destination port number)를 헤더에 가진다.

  - length, checksum 필드도 있지만 그리 중요하지는 않다.
  - length는 header를 포함해 segment의 총 길이가 얼마나 되는지를 표시한다.
    - app data payload의 크기가 가변적이기에 전체 길이를 표시한다. 그래야 receiver측에서 payload가 얼마나 되는지를 가늠할 수 있기 때문이다.
  - checksum 필드의 경우 전송된 segment에 error가 있는지를 감시하는 field이다.
    - receiver가 자신이 계산한 checksum과 sender가 넣은 checksum value를 비교하여 맞으면 error 없고, 틀리면 error가 있다고 판단한다.
    - UDP는 reliable transport하지 않는다!
      - 그렇기에 이 결과를 가지고 UDP가 어떻게 행동할지는 프로토콜이 정의하고 있지 않다.
      - UDP implement dependent, 즉 UDP가 application으로 하여금 직접 판단하고 행동할 수 있도록 에러 사항을 올릴 수도 있고 그렇지 않을 수도 있다.

  <br>

- conjestion control이 없기에 application이 data를 생성하는 속도로 network에 데이터를 밀어넣을 수 있다.

<br>

<br>

<br>

#### [3.4. principles of reliable data transfer]

<br>

- reliable data transfer를 위해 어떤 프로토콜 요소들이 필요할까?

<br>

1. checksum field

   - receiver가 segment를 받았을 때 그 segment에 오류가 있는지를 판단하기 위함

   <br>

2. acknowledgement field

   - sender에게 packet을 잘 받았다고 알려주기 위함
     - individual packet에 대한 것일수도, cumulative packet들에 대한 것일 수도 있다.

   <br>

3. negative acknowledgement field

   - 어떤 packet이 잘못 되었는지를 sender에게 알려주는 field
     - 일반적으로 특정 packet을 찝어서 이야기한다.
   - 그러면 reliable transfer를 위해 해당 packet에 대해 retransfer한다. (sender)

   <br>

4. timer

   - receiver가 패킷을 받지 못한 채 네트워크가 패킷을 drop하는 경우가 있다.
   - receiver는 받은 패킷이 없으므로 acknowledgent, negative acknowledgement를 보내지 않는다.
   - 그러면 sender는 한없이 기다려야 한다. acknowledgement를 받아야 다음 data를 보낼 수 있기 때문이다. 이 때문에 timer가 필요하다.
   - sender측에서 data를 보내놓고 기다려도 반응이 오지 않으면 네트워크가 drop했다고 가정하고 retransmit하게 된다.
     - 하지만 불필요한 retransmit이 발생할 수도 있다. acknowledgement가 drop될 수 있기 때문
     - timer 때문에 받았던 packet이 또 전송될 수 있기에 packet의 id인 sequence number가 필요하다.

   <br>

5. window, pipelining

   - sender-receiver 사이의 network를 pipe로 보자. pipe 내 packet이 최대 몇 개 있을 수 있을까?
     - 하나!
     - pipe가 길고 넓다면 빨리 실어나르기 위해서는 잘 받았다는 acknowledgement가 오지 않더라도 packet을 집어넣으면 된다. (-> pipelining) 활용률 증가!
   - window는 acknowledgement를 받지 않은 상태에서 집어넣을 수 있는 최대 data 양
   - window 양만큼 pipelining. (acknowledgement 받지 않은 상태에서 네트워크에 데이터 밀어넣기)

<br>

<br>

<br>

#### [3.5. connection-oriented transport: TCP]

<br>

- TCP는 reliable, in-order transfer를 해주는데, 사용자의 데이터를 byte stream으로 본다.
  - TCP는 유저가 메시지를 내려보내면 일단 buffer에 받는다.
  - 네트워크에 내려보낼 때는 conjestion control과 flow control에 의해 제어되는 rate으로 뽑아 내려보낸다.
  - user message boundary는 인식하지 않고 buffer에 drop시킨 data를 byte의 연속으로 본다.
  - 그래서 maximum segment size에 따라 자르고 그만큼의 데이터를 하나의 segment로 묶어 보낸다.
  - 받는 측에서도 네트워크에서 데이터를 올려보내면 우선 buffer에 받는다. 이후 boundary를 인식하지 않고 사용자가 적절하게 자기가 원하는 양만큼 읽어가도록 한다.

<br>



