## Django project 2 분석 (Django REST Framework)

<br>

```python
[살펴볼 것들]

1. Serializer/ModelSerializer를 통한 데이터 유효성 검증 및 데이터 직렬화
2. 각종 Parser를 통한 데이터 처리
3. APIView/Generic/ViewSet/ModelViewSet을 통한 요청 처리
4. 각종 Renderer를 통한 다양한 응답 포맷 지원
5. 인증(Authentication) / 권한(Permission) 체계 - 써드파티를 통해 JWT 지원
6. Throttling (최대 호출 횟수 제한)


[REST API 스타일로 재설계]  # DRF: 정형화된 중복을 줄이자

/모델/
1. GET 방식 요청  # 목록 응답
2. POST 방식 요청  # 새 글 생성, 확인 응답

/모델/10/
3. GET 방식 요청  # 글 내용 응답
4. PUT 방식 요청  # 수정, 저장하고 확인 응답
5. DELETE 방식 요청  # 글 삭제하고 확인 응답


[APIView -> Mixin -> Generics -> ViewSet]
# 표준화, 추상화 순서
# Mixin에서도 클래스 메서드 각각 정의해야 함

Generic까지는 하나의 클래스가 하나의 URL에만 매핑
ViewSet은 하나의 클래스가 다수의 URL에 매핑


[ModelViewSet]

- viewsets.ReadOnlyModelViewSet
# url1: list
# url2: detail

- viewsets.ModelViewSet
# url1: list/create
# url2: detail/update/partial_update/delete
```

<br>

<br>

<br>

## Projects App (mycompany2/)

<br>

#### [mycompany2/settings.py]

<br>

```python
"""
Django settings for mycompany2 project.

Generated by 'django-admin startproject' using Django 3.1.5.

For more information on this file, see
https://docs.djangoproject.com/en/3.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/3.1/ref/settings/
"""
import os
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent
# path의 .resolve() 메서드는 전체 경로(full path)를 찾는다.
# __file__(현 파일)의 상위, 상위 dir이므로 곧 mycompany2를 거쳐 root directory인 mysite2를 가리키게 됨
# 결국 os와 같음 (아래 링크 참조)
# https://blog.naver.com/PostView.nhn?blogId=hankrah&logNo=221838907175&categoryNo=0&parentCategoryNo=0&viewDate=&currentPage=1&postListTopCurrentPage=1&from=postView


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/3.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'b+ic+oe-phm*kw(0kljj@q!l@ph)wl$#=@5$if@m-rlgw7&!^q'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'rest_framework.authtoken',
    'accounts',
    'instagram2',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'mycompany2.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'mycompany2.wsgi.application'


# Database
# https://docs.djangoproject.com/en/3.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}


# Password validation
# https://docs.djangoproject.com/en/3.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/3.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.1/howto/static-files/

STATIC_URL = '/static/'


REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        # 'rest_framework.authentication.TokenAuthentication',
        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',
    ],
    'PAGE_SIZE': 10,
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    # 페이지 전역설정
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],  # permission 전역 설정(모든 뷰에 대해 로그인이 되어 있어야 접근 가능)
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.UserRateThrottle',
    ],
    'DEFAULT_THROTTLE_RATES': {
        # 'anon': None, (Default)
        'user': '3/day',
    },
}

JWT_AUTH = {
    'JWT_ALLOW_REFRESH': True,
}  # 토큰 refresh할거냐?
```

<br>

<br>

<br>

#### [mycompany2/urls.py]

<br>

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api-auth/', include('rest_framework.urls')),
    # api-auth/는 이름 원하는대로 한 것, rest_framework setting
    # 실제 로그인 주소 localhost:8000/api-auth/login/?next=/post/
    # django 기본 앱에 있는 auth앱을 통해서 처리를 하고 있음
    path('accounts/', include('accounts.urls')),
    path('', include('instagram2.urls')),
]
```

<br>

<br>

<br>

#### [mycompany2/asgi.py]

<br>

```python
"""
ASGI config for mycompany2 project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mycompany2.settings')

application = get_asgi_application()
```

<br>

<br>

<br>

#### [mycompany2/wsgi.py]

<br>

```python
"""
WSGI config for mycompany2 project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mycompany2.settings')

application = get_wsgi_application()
```

<br>

<br>

<br>

## Instagram App (Instagram2/)

<br>

#### [instagram2/admin.py]

<br>

```python
from django.contrib import admin
from .models import Post


@admin.register(Post)
class PostAdmin(admin.ModelAdmin):
    search_fields = ['message']  # 메시지를 통해 검색 가능
    list_display = ['pk', 'message', 'author']  # admin page에 보여줄 list
```

<br>

<br>

<br>

#### [instagram2/apps.py]

<br>

```python
from django.apps import AppConfig


class Instagram2Config(AppConfig):
    name = 'instagram2'
```

<br>

<br>

<br>

#### [instagram2/forms.py]

<br>

```python
from django.forms import ModelForm
from .models import Post


class PostForm(ModelForm):
    class Meta:
        model = Post
        # fields = '__all__'
        fields = ['message', 'is_public']
```

<br>

<br>

<br>

#### [instagram2/models.py]

<br>

```python
from django.conf import settings
from django.db import models


class Post(models.Model):
    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    message = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_public = models.BooleanField(default=False, db_index=True)
    ip = models.GenericIPAddressField(null=True, editable=False)
    # editable=False: 유저가 직접 자기 ip를 쓰는게 상식에 어긋나므로 False로 지정
    # 조회만 가능, 수정 불가능
```

<br>

<br>

<br>

#### [instagram2/permissions.py]

<br>

```python
from rest_framework import permissions
# permission 활용시 APIView를 상속받아 써야 함


class IsAuthorOrReadonly(permissions.BasePermission):
    # 인증이 되어야만, 목록조회 및 포스팅 등록을 허용
    def has_permission(self, request, view):
        return request.user and request.user.is_authenticated
    # 현 유저가 존재하는지, 해당 유저가 인증을 통과한 유저인지 return

    def has_object_permission(self, request, view, obj):
        if request.method in permissions.SAFE_METHODS:
            return True
        # GET, HEAD, OPTIONS에 해당하는 read request(readonly)라면, 아무나 가능
        # HEAD: 실제 응답 헤더만 받아보기
        # OPTION: 해당 endpoint에서 어떠한 메서드를 지원하는지 알려주는 interface

        return obj.author == request.user
    	# 그런데 write 기능이라면, 해당 객체의 author만이 접근 가능
        # 따라서 현 유저가 obj.author와 같은지, 다른지 return
        # 모델에 따라 author가 없을 수 있음. 현재 이 경우는 author라는 외래키 필드가 있다는 가정
```

<br>

<br>

<br>

#### [instagram2/serializers.py]

<br>

```python
from django.contrib.auth import get_user_model
# def get_user_model():
#    """
#    Return the User model that is active in this project.
#    """
#    try:
#        return django_apps.get_model(settings.AUTH_USER_MODEL, require_ready=False)
#    except ValueError:
#        raise ImproperlyConfigured \
#        	("AUTH_USER_MODEL must be of the form 'app_label.model_name'")
#    except LookupError:
#        raise ImproperlyConfigured(
#            "AUTH_USER_MODEL refers to model '%s' that has not been installed" \
#            % settings.AUTH_USER_MODEL
#        )

from rest_framework import serializers
from .models import Post


class AuthorSerializer(serializers.ModelSerializer):  # ModelForm과 비슷
    class Meta:
        model = get_user_model()
        fields = ['username', 'email']


class PostSerializer(serializers.ModelSerializer):
    author_username = serializers.ReadOnlyField(source='author.username')
    # author = AuthorSerializer() / 밑 fields에 'author' 넣어주는 것과 같음
    # source는 필드를 채우는데 사용할 속성의 이름임
    # ReadOnlyField는 변경 없이 필드의 값만 돌려주는 field class

    class Meta:
        model = Post
        fields = [
            'pk',
            'author_username',
            # 얘는 models.py에 없었기에 위에서 정의하고 필드에 넣음
            'message',
            'created_at',
            'updated_at',
            'is_public',
            'ip',
        ]
```

<br>

<br>

<br>

#### [instagram2/urls.py]

<br>

```python
from django.urls import path, include
from rest_framework.routers import DefaultRouter
# DefaultRouter는 API root view를 자동 생성해줌, views.py에서 api_root 메서드 지워도 됨
from . import views

router = DefaultRouter()
router.register('post', views.PostViewSet)  # 2개 url을 만들어준다.
# router.urls에 리스트 형태로 존재하게 됨 (url pattern list)
# router가 알아서 resource들을 view에 연결해줌, viewset만 적절히 등록하면 됨
# 따라서 router 만들고, (URL prefix, viewset)을 인자로 넣어주면 됨

urlpatterns = [
    path('mypost/<int:pk>/', views.PostDetailAPIView.as_view()),
    # path('public/', views.public_post_list),
    path('', include(router.urls)),  # API URL들은 router에 의해서 자동으로 결정됨
]
```

<br>

<br>

<br>

#### [instagram2/views.py]

<br>

```python
from rest_framework import generics
# ex. generics.ListAPIView의 경우 /post/의 get(list) 기능만 지원하는 것
# 다 지원하고 싶다? ViewSet!
from rest_framework.decorators import api_view, action
from rest_framework.filters import SearchFilter, OrderingFilter
from rest_framework.generics import RetrieveAPIView
from rest_framework.permissions import IsAuthenticated
# 인증 유저 통과, 비인증 유저 허가 권한 미부여
from rest_framework.renderers import TemplateHTMLRenderer
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.viewsets import ModelViewSet

from .permissions import IsAuthorOrReadonly
# 인증이 되어야만 어떤 request도 수행하도록 함
from .serializers import PostSerializer
from .models import Post


# Generics 사용
# class PublicPostListAPIView(generics.ListAPIView):
#     queryset = Post.objects.filter(is_public=True)
#     serializer_class = PostSerializer


# APIView 사용, 여기서는 지원할 메서드 만들어주기
# class PublicPostListAPIView(APIView):
#     def get(self, request):
#         qs = Post.objects.filter(is_public=True)
#         serializer = PostSerializer(qs, many=True)
#         return Response(serializer.data)
#
# public_post_list = PublicPostListAPIView.as_view()


# 장식자 사용 (FBV)
# @api_view(['GET'])  # 인자로 어떤 메서드 지원할지 써줘야
# def public_post_list(request):
#     qs = Post.objects.filter(is_public=True)
#     serializer = PostSerializer(qs, many=True)
#     return Response(serializer.data)


class PostViewSet(ModelViewSet):  
    # GET, POST / GET, PUT, DELETE 5개 view 모두 처리
    # 만약 이거 없었다면 def post_list, def post_detail 만들어서 처리해야했음
    # 그럼 실제 2개의 URL(ex. /post/, /post/10/)인건데 어떻게 처리? router!
    queryset = Post.objects.all()
    serializer_class = PostSerializer
    # authentication_classes = []  # 인증이 됨을 보장받을 수 있습니다.
    permission_classes = [IsAuthenticated, IsAuthorOrReadonly]
    filter_backends = [SearchFilter, OrderingFilter]
    search_fields = ['message']
    # 어떤 필드에 대해서 searchfilter를 적용할 것인가?
    # ?search='메시지 문자열' 페이지에서 해당 문자열이 포함된 포스팅만 보여지게 됨
    # OrderingFilter를 필드 지정 안하고 이렇게 필터만 적용한다면 모든 필드에 대해 정렬을 수행할 수 있게 됨
    # ex) ordering=-pk라고 주소 뒤에 적어주면 내림차순 정렬 적용

    def perform_create(self, serializer):
        # FIXME: 인증이 되어 있다는 가정하에, author를 지정함
        author = self.request.user  # User or AnonymousUser
        ip = self.request.META['REMOTE_ADDR'] # client의 IP 주소 참조
        serializer.save(author=author, ip=ip)
        # 폼을 사용했다면, 폼에 message와 is_public만 필드에 지정되어 있으므로
        # form.save(commit=False)로 두고 author와 ip를 지정해준 다음 form.save()를 했을 것
        # 그런데 serializer에서는 serializer.save(author=author, ip=ip)식으로 직접 인자에 지정
        # 즉, 내가 업데이트하고 싶은 인자를 키워드로 넘겨줌

    @action(detail=False, methods=['GET'])
    # custom action(public) 생성
    # create, update, delete와 같은 표준 action 이외의 것
    # action 장식자 쓰는 action은 디폴트가 GET request
    # POST request에 응답하는 action을 지정하려면 methods 써야
    # default=False: 특정 대상을 찍느냐 안 찍느냐
    # public은 list 관점에서 목록을 주는 것이니까
    # 결국 2개의 URL 중 List.url을 탐
    def public(self, request):
        qs = self.get_queryset().filter(is_public=True)
        # 그냥 .queryset()보다 wrapping된 형태
        serializer = self.get_serializer(qs, many=True)
        return Response(serializer.data)

    @action(detail=True, methods=['PATCH'])
    # set_public은 특정 포스팅을 찍는 것이기에 detail=True
    # 결국 2개의 URL 중 Detail.url을 탐
    # 뒤에 methods는 어느 메서드에 대해 반응할 것인가를 쓴 것
    def set_public(self, request, pk):
        instance = self.get_object()
        # get_object(queryset=None)
        # view가 보여줄 single object return
        instance.is_public = True
        instance.save(update_fields=['is_public'])  # is_public만 db에 update
        serializer = self.get_serializer(instance)
        return Response(serializer.data)

    
    # 실제 요청이 올 때마다 호출되는 함수
    # def dispatch(self, request, *args, **kwargs):
    #     print("request.body :", request.body)  # print 비추천, logger 추천
    #     print("request.POST :", request.POST)
    #     return super().dispatch(request, *args, **kwargs)


class PostDetailAPIView(RetrieveAPIView):
    queryset = Post.objects.all()
    renderer_classes = [TemplateHTMLRenderer]  # 아래 템플릿 활용
    template_name = 'instagram2/post_detail.html'
    # renderer_classes, template_name 2개 빼면 json 응답
    # json 응답은 serializer의 도움을 받아야 하지만, template render 시에는 불필요

    def get(self, request, *args, **kwargs):
        post = self.get_object()  # RetrieveAPIView 내부에 이미 get_object() 구현되어 있음
        return Response({
            'post': post,
        })
```

<br>

<br>

<br>

#### [instagram2/templates/instagram2/post_detail.html]

<br>

```python
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>
</head>
<body>

    {{ post }}

</body>
</html>
```

<br>

<br>

<br>

## Accounts App (accounts/)

<br>

- admin, models, views 내용 없음

<br>

#### [accounts/apps.py]

<br>

```python
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    name = 'accounts'
```

<br>

<br>

<br>

#### [accounts/urls.py]

<br>

```python
from django.urls import path
from rest_framework.authtoken.views import obtain_auth_token
from rest_framework_jwt.views import obtain_jwt_token, refresh_jwt_token, verify_jwt_token

urlpatterns = [
    # path('api-token-auth/', obtain_auth_token),
    path('api-jwt-auth/', obtain_jwt_token),  # 토큰 얻기
    path('api-jwt-auth/refresh/', refresh_jwt_token),  # 토큰 refresh
    path('api-jwt-auth/verify/', verify_jwt_token),  # client가 가진 토큰이 유효한 토큰인지 검사
]
```
