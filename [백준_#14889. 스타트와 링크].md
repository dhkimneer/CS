### [# 14889. 스타트와 링크]

<br>

- 2초 / 512MB

- 축구하려고 모인 인원 N명, 짝수
- 스타트팀 / 링크팀 두 팀으로 나눔
- 스타트팀의 능력치와 링크 팀의 능력치의 차이를 최소로 하는 것이 목표

<br>

- 입력값

  - 첫째 줄: N (4이상 20 이하, 짝수)이 '주어짐'
  - 둘째 줄부터 N개 줄에 S '주어짐'
    - 각 줄은 N개의 수로 이뤄져 있음 (능력치)
    - Sii = 0, 1 <= Sij <= 100

  <br>

- 출력값

  - 스타트 팀의 능력치와 링크 팀의 능력치의 차이의 최솟값

<br>

<br>

#### [풀이 1 - BruteForce]

<br>

1. 시간 복잡도 계산

   <br>

   - N명의 사람이 각각 스타트 팀으로 들어가는가, 링크 팀으로 들어가는가?의 문제이다.

     - 능력치는 그저 팀이 정해지고 나면, 팀마다 계산해서 그 능력치들의 차이(이후 최솟값)를 계산하는 용도로 쓰일 뿐이다.

     <br>

   - 결국, 각각의 사람이 '기준'이 된다.

     - 즉 첫 번째 사람이 과연 스타트 팀으로 들어가느냐 아니면 링크 팀으로 들어가느냐?
     - 두 번째 사람은?
     - 세 번째 사람은? ... 이렇게 계속 사람을 기준으로 한다.

     <br>

   - 첫 번째 사람이 고를 수 있는 경우의 수는 2가지, 이후 사람들도 마찬가지다. 결국, N명까지 모두 고려를 하게 되면 O(2^N)의 시간 복잡도로 볼 수 있다.

     - 최악의 경우 N = 20이므로 2^20을 계산해본다.
     - 2^10 = 1024, 대략 10^3이므로 2^20 값은 대략 10^6이 된다.
     - 문제에 제시된 2초 안에 들어오기에 충분하므로 브루트 포스가 가능하다.

     <br>

   - 이후 각 팀의 멤버들을 순회하면서 능력치를 합하는 단계가 필요하므로 ??

<br>

2. 재귀를 쓸건데, 인자로 담을 값 확인 (기준이 바뀌었을 때, 바뀌는 값들을 모두 함수의 인자로 넣자.)

   <br>

   - 사람을 어느 팀에 넣을지 결정해야 한다. 이번 사람을 체크했으면, 다른 사람 턴으로 넘어간다.

     - 즉, index가 바뀐다.

     <br>

   - 각 팀의 멤버가 추가된다.

     - 그래서 스타트팀, 링크팀의 멤버를 담을 것이 필요하다. (start, link)
     - 구체적으로 start

     <br>

   - 능력치 관련해서는 입력값에 주어져 있고, 다음 턴으로 넘어간다고 해서 변경되는 사항은 없다.

<br>

3. 3가지 경우를 확인한다.

   <br>

   1) 다음 경우 호출 시 어떻게 호출해야 하나?

   <br>

   - 스타트팀에 들어갔을 경우

     <br>

     - go(index + 1, start + [index], link)
       - 다음 사람 턴을 고려할 때는 다음 사람 index를 고려해야 하므로 하나 더해준다.
       - 해당 index 사람이 start팀에 들어갔으므로 index를 추가한다.
       - link팀에 들어가지 않았으므로 그대로 있는다.

     <br>

   - 링크팀에 들어갔을 경우

     <br>

     - go(index + 1, start, link + [index])
       - 스타트팀에 들어갔을 경우와 반대로 생각하면 된다. index는 논리가 같다.

   <br>

   2) 정답을 찾았을 경우

   <br>

   - 0번째 사람부터 (n - 1)번째 사람으로 지칭한다고 가정하자.

   - 다음 경우를 호출하는 데 있어 index가 n까지 왔다면, 모든 사람을 다 고려했다고 볼 수 있다.

     - 즉, index == n까지 오면 완성된다.

     <br>

   - 팀을 다 나누고 나서, 각 팀의 구성원이 실제로 n / 2명씩 배정되었는지 확인하는 절차가 필요하다.

     <br>

   - 잘 나눠졌다면 각 팀의 능력치를 합해 차이를 구하고, 그 경우들을 비교해 최솟값을 구해야 한다.

     - 여기서 각 팀의 능력치 합을 담을 변수 2개가 필요하다.
     - 차이를 담을 변수도 필요하다.
     - 답을 내기 위해 답을 담을 변수도 필요하다.

   <br>

   3) 불가능한 경우

   <br>

   - index가 n을 넘어간다? 작다? 이 경우는 고려대상이 아닌 것이 n명의 사람이 주어져 있고, 각 사람의 경우를 모두 돌아보기에 '불가능'한 경우를 찾기 어렵다.

   <br>

   - 각 팀의 구성원이 각각 n / 2명씩 배정되지 않았을 때 불가능하다. (check!)

   <br>

   - 능력치 합의 차이를 구하고, 최솟값을 구하는 데 있어 불가능한 경우는 없다. 말 그대로 구하는 것

<br>

4. 소스 구현

<br>

- 우선 입력값을 받는 데 있어 해당 입력값들은 저렇게 주어진거고, 나는 그걸 이용한다.
  - 첫째 줄은 n을 그대로 받는다.
  - 둘째 줄부터 시작하는 능력치 줄들은 각각의 index(사람)에 대한 능력치들이므로 쉽게 값에 접근하기 위해 list 내 list 형태로 만들어 사용할 것이다.
    - 사실 그래서 위에서 다음 경우 호출 재귀 함수 정의할 때 start + [index] 식으로 표현했다.

<br>

```python
def go(index: int, start: list, link: list) -> int:
    # 2. 정답을 찾은 경우
    if index == n:
        # 3. 불가능한 경우 가려내기
        if len(start) != n // 2:
            return -1
        if len(link) != n // 2:
            return -1
        
        # 계속해서 정답 찾기: 각 팀 능력치 합 구하고 차이 최솟값 구하기
        start_sum = 0  # start팀 능력치 합 저장
        link_sum = 0  # link팀 능력치 합 저장
        for i in range(n // 2):
            for j in range(n // 2):
                if i == j:
                    continue
                start_sum += s[start[i]][start[j]]
                link_sum += s[link[i]][link[j]]
        diff = abs(start_sum - link_sum)
        return diff
    
    
    ans = -1
    
    # 첫 번째 사람이 start 그룹에 들어갈 경우부터 재귀 시작(이후 모든 경우 탐색)
    diff_1 = go(index + 1, start + [index], link)
    # 초깃값 -1(최소)이 유지되고 있다면 diff_1로 바꿔주기
    # 이후에는 불가능한 경우가 아니면서 기존 ans보다 더 낮은 값이면 최솟값 변경 
    if ans == -1 or (diff_1 != -1 and ans > diff_1):
        ans = diff_1
        
    # 첫 번째 사람이 link 그룹에 들어갈 경우부터 재귀 시작(이후 모든 경우 탐색)
    diff_2 = go(index + 1, start, link + [index])
    # 역시나 초깃값 -1(최소)이 유지되고 있다면 diff_1로 바꿔주기
    # 역시 불가능한 경우가 아니면서 기존 ans보다 더 낮은 값이면 최솟값 변경
    if ans == -1 or (diff_2 != -1 and ans > diff_2):
        ans = diff_2
        
    return ans

n = int(input())
s = [list(map(int, input().split())) for _ in range(n)]
print(go(0, [], []))
```

<br>

<br>

#### [풀이 2 - Backtracking]

<br>

- 최적화할 수는 없을까? 
  - Brute Force + 조건 = Backtracking
  - 조건을 추가해 함수 호출을 중간에 중단시키는 것이 목표이다.
  - 조건을 찾을 수 있어야 한다.

<br>

- 함수 호출 중 어떤 팀의 인원이 n / 2명을 넘는 경우 중간에 호출을 중단함으로써 최적화가 가능하다.
  - 위에서는 모든 경우를 다 살핀 다음에 팀의 인원이 n / 2가 맞는지 아닌지를 판별했었다.

<br>

- how?

<br>

```python
def go(index: int, start: list, link: list) -> int:
    if index == n:
        if len(start) != n // 2:
            return -1
        if len(link) != n // 2:
            return -1
        
        start_sum = 0
        link_sum = 0
        for i in range(n // 2):
            for j in range(n // 2):
                if i == j:
                    continue
                start_sum += s[start[i]][start[j]]
                link_sum += s[link[i]][link[j]]
        diff = abs(start_sum - link_sum)
        return diff
     
    # 재귀 함수 호출 전에 팀 인원이 n // 2명이 넘어버렸다면 호출 중단한다.
    if len(start) > n // 2:
        return -1
    if len(link) > n // 2:
        return -1  # 추가 완료
    
    ans = -1
    
    diff_1 = go(index + 1, start + [index], link)
    if ans == -1 or (diff_1 != -1 and ans > diff_1):
        ans = diff_1
        
    diff_2 = go(index + 1, start, link + [index])
    if ans == -1 or (diff_1 != -1 and ans > diff_2):
        ans = diff_2
```